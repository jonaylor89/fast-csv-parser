# Build-Safe Architecture

This document explains how the fast-csv-parser package is structured to be build-safe, meaning the Transform stream functionality won't be overwritten when the native bindings are rebuilt.

## Problem

The original approach of combining the Transform stream code directly into `index.js` had a critical issue: `index.js` is auto-generated by NAPI-RS and gets completely overwritten on every build. This meant that after running `npm run build`, all the Transform stream functionality would be lost.

## Solution

We've implemented a **two-file architecture** that separates concerns:

### File Structure

```
fast-csv-parser/
├── index.js    # Auto-generated native binding loader (build-safe)
├── main.js     # Transform stream implementation (build-safe)
└── package.json # Points to main.js as entry point
```

### Architecture Details

1. **`index.js`** - Auto-generated by NAPI-RS
   - Contains platform-specific native binding loading logic
   - Gets completely regenerated on every build
   - Exports only the native `CsvParser` class
   - Should never be manually edited

2. **`main.js`** - Hand-written Transform stream wrapper
   - Imports `CsvParser` from `index.js`
   - Provides the csv-parser compatible Transform stream API
   - Implements `mapHeaders`, `mapValues`, headers events, etc.
   - Safe from build regeneration
   - This is the main entry point for the package

3. **`package.json`** - Configuration
   - `"main": "main.js"` points to our stable entry point
   - Build process only affects `index.js`, never `main.js`

## Benefits

✅ **Build-Safe**: Running `npm run build` never overwrites the Transform stream code
✅ **Clean Separation**: Native bindings vs Stream API are separated
✅ **API Compatibility**: Full backward compatibility with csv-parser
✅ **Maintainable**: Clear separation of auto-generated vs hand-written code

## Usage

Users can import the package normally:

```javascript
const csv = require('fast-csv-parser');
// or
import csv from 'fast-csv-parser';
```

The package.json `main` field ensures they get the `main.js` file, which provides the complete API including both the Transform stream interface and access to the native `CsvParser` class.

## Development Workflow

1. **Native Code Changes**: Edit Rust code in `src/`
2. **Build**: Run `npm run build` - this regenerates `index.js`
3. **Stream API Changes**: Edit `main.js` - this is never overwritten
4. **Test**: Run `npm test` - all tests use `main.js`

## Files That Import main.js

- All test files in `__test__/`
- Benchmark scripts in `bin/`
- Example files in `examples/`
- Any user code that requires the package

## Verification

To verify the architecture works after builds:

```bash
# Build the native bindings
npm run build

# Verify functionality still works
node -e "const csv = require('./main.js'); console.log('✓ Works after build');"

# Run tests
npm test
```

This architecture ensures that the package remains fully functional regardless of how many times the native bindings are rebuilt.